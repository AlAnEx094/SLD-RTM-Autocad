# KR_RESOLVER — контракт расчёта Kr (РТМ 36.18.32.4-92, Таблица 1)

Этот документ фиксирует **жёсткий контракт** вычисления коэффициента спроса/разновременности `Kr`
по табличным данным РТМ (Таблица 1). Любая реализация `get_kr()` должна соответствовать правилам ниже.

## Источник данных (DB = истина)

Таблица `kr_table` хранится в SQLite и является **единственным источником правды** для `Kr`.

Схема хранения (жёстко задано):

- `ne` (INT): табличное значение \(n_e\) (строка таблицы)
- `ki` (REAL): табличное значение \(K_i\) (столбец таблицы)
- `kr` (REAL): табличное значение \(K_r\) (ячейка таблицы)
- `source` (TEXT): строковый идентификатор источника (например: `RTM_36.18.32.4-92_Table_1`)
- PK: `(ne, ki)`

## Вход/выход функции

Функция `get_kr(db_path, ne, ki) -> float`:

- **вход**:
  - `db_path`: путь к SQLite (файл проекта)
  - `ne`: расчётное \(n_e\) (не обязательно табличное)
  - `ki`: расчётное \(K_i\) (не обязательно табличное)
- **выход**:
  - `Kr` (float)

## Жёсткие правила вычисления Kr

### 1) Clamp по Ki

Перед любыми действиями делается ограничение:

- если `ki < 0.10`, то используем `ki_clamped = 0.10`
- если `ki > 0.80`, то используем `ki_clamped = 0.80`
- иначе `ki_clamped = ki`

Важно: **clamp влияет только на lookup/interpolation `Kr`**. Исходное значение `ki` должно храниться отдельно от расчёта.

### 2) Выбор табличного `ne_tab` (округление вверх)

Из существующих в `kr_table.ne` выбирается:

- `ne_tab` = **минимальное табличное `ne`, которое >= `ne`**

Иначе говоря, это округление вверх к ближайшей существующей строке.

Если подходящей строки нет (например, `ne` больше максимального табличного), реализация **должна завершаться ошибкой**
(`ValueError`/исключение домена) — чтобы не подменять методику молчаливым поведением.

### 3) Интерполяция только по Ki внутри выбранной строки

После выбора `ne_tab`:

- берём **только** значения `Kr` из строки `ne = ne_tab`
- `Kr` вычисляется **только по оси Ki** (линейная интерполяция)
- интерполяция выполняется **только между соседними табличными `ki`**, ограничивающими `ki_clamped`

#### 3.1) Точное попадание в табличный столбец

Если `ki_clamped` совпадает с одним из табличных `ki` в строке `ne_tab` (с учётом точного значения, хранящегося в БД),
то:

- `Kr = kr_table.kr` для этой ячейки

#### 3.2) Линейная интерполяция

Если точного совпадения нет:

- находим `ki_lo` = максимальное табличное `ki` такое, что `ki_lo < ki_clamped`
- находим `ki_hi` = минимальное табличное `ki` такое, что `ki_hi > ki_clamped`
- берём `kr_lo` и `kr_hi` из таблицы для `ne_tab`
- считаем:

\[
Kr = kr_{lo} + \frac{(ki_{clamped} - ki_{lo})}{(ki_{hi} - ki_{lo})} \cdot (kr_{hi} - kr_{lo})
\]

Если для интерполяции не хватает соседей (нет `ki_lo` или `ki_hi`), реализация **должна завершаться ошибкой**,
потому что таблица в БД неполная для данного диапазона.

## Нефункциональные требования

- **Детерминированность**: одинаковые входы при одинаковой БД дают одинаковый `Kr`.
- **Отсутствие “умных” эвристик**: никаких интерполяций по `ne`, никаких “ближайших” строк, кроме правила округления вверх.
- **DB-first**: приоритет корректности данных в БД, а не подгонка результата.

